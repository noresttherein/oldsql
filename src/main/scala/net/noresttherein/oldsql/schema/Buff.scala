package net.noresttherein.oldsql.schema

import java.sql

import net.noresttherein.oldsql.schema.Buff.BuffType
import net.noresttherein.oldsql.schema.Mapping.{ColumnFilter, TypedMapping}
import net.noresttherein.oldsql.schema.bits.Temporal
import net.noresttherein.oldsql.slang._

import scala.reflect.ClassTag



/** An optional annotation/modifier for component mappings, especially columns.
  * Modifies the way the annotated component is mapped, in particular it is used to include or exclude
  * certain columns from select/insert/update statements.
  * @tparam T the value type of the annotated component.
  */
trait Buff[+T] {

	/** Does this buff belong to the buff group defined by `group`, carrying information defined by the group?
	  * this will be true if this buff was created by this group or if the group which created this buff
	  * has strictly narrower meaning than the passed argument, effectively implying the latter.
	  */
	def is(group :BuffType) :Boolean = factory.implies(group)

	/** Adapts this buff for a new component type. For flag buffs, this is an identity operation; for buffs
	  * with values it creates a new buff of the same type carrying the mapped value.
	  */
	def map[X](there :T=>X) :Buff[X]



	/** The type of this buff, i.e. the factory that created this instance. */
	def factory :BuffType


	def canEqual(that :Any) :Boolean = that.getClass == this.getClass

	override def equals(that :Any) :Boolean = that match {
		case o:Buff[_] => (this eq o) || o.canEqual(this) && factory == o.factory
		case _ => false
	}

	override def hashCode :Int = getClass.hashCode

	override def toString :String = factory.toString
}






object Buff {

	/** This column/component is not included in the default select statement and must be specified explicitly,
	  * if at all possible. */
	case object NoSelectByDefault extends AbstractBuffType

	/** This column/component is not included in the default insert statement and must be specified explicitly,
	  * if at all possible. */
	case object NoInsertByDefault extends AbstractBuffType

	/** This column/component is not included in the default update statement and must be specified explicitly,
	  * if at all possible. */
	case object NoUpdateByDefault extends AbstractBuffType

	/** This column/component is not included as the parameter of the default query statement searching for
	  * an equal entity and must be specified explicitly, if at all possible. */
	case object NoQueryByDefault extends AbstractBuffType



	/** This column/component can't be included in a select statement (as part of its header). */
	case object NoSelect extends ComboFlag(NoSelectByDefault)
	/** This column/component can't be included in an insert statement (as the inserted column). */
	case object NoInsert extends ComboFlag(NoInsertByDefault)
	/** This column/component can't be included in an update statement (as the updated column). */
	case object NoUpdate extends ComboFlag(NoUpdateByDefault)
	/** This column/component can't be included as part of the where clause of a select or update statement. */
	case object NoQuery extends ComboFlag(NoQueryByDefault)

	/** This column/component is never written to the database by the application. */
	case object ReadOnly extends ComboFlag(NoInsert, NoUpdate)

	/** A buff type which marks columns ignored by the enclosing mapping. It is useful when a column is still
	  * used as part of SQL statements. */
	case object Unmapped extends ComboFlag(ReadOnly, NoSelect, NoQuery)



	/** The value for this column/component is generated by the database on insert and should be returned by the
	  * insert statement. */
	case object AutoInsert extends ComboFlag(NoInsert)

	/** The value for this column/component is updated by the database whenever a mapped row is updated. */
	case object AutoUpdate extends ComboFlag(NoUpdate)

	/** The value for this column/component is generated by the database on insert and updated on each update,
	  * making it read only for the application. */
	case object AutoGen extends ComboFlag(AutoInsert, AutoUpdate, ReadOnly)



	/** A factory for buffs marking that a given column/component can be omitted from the select clause.
	  * It is still included by default and needs to be excluded explicitly. Created values carry a placeholder
	  * value to assign to the annotated component on assembly. */
	case object OptionalSelect extends GeneratedBuffType

	/** A factory for buffs marking that a given column/component is omitted by default from the select clause
	  * and needs to be included explicitly. When not included, the value stored in the buff will be used
	  * as the value for the annotated component. It implies `OptionalSelect` and `NoSelectByDefault`. */
	case object ExplicitSelect extends ComboBuffType(OptionalSelect, NoSelectByDefault) with GeneratedBuffType

	/** A buff marking a column as non-selectable, and providing the value for the annotated component.
	  * This can be used in particular for 'virtual' columns - components which take part in the mapping, but
	  * aren't present in the database at all. */
	case object ExtraSelect extends ComboBuffType(NoSelect) with GeneratedBuffType



//	/** A buff marking that a given column/component can be omitted from the the parameter list of the where
//	  * clause of an update statement. It is still included by default and needs to be excluded explicitly. */
//	case object OptionalQuery extends FlagBuff
//
//	/** A buff marking that a given column/component can be omitted from the parameter list of the where clause
//	  * of an update statement and needs to be included explicitly. It implies `OptionalQuery` and `NoQueryByDefault`. */
//	case object ExplicitQuery extends ComboFlag(OptionalQuery, NoQueryByDefault)

	/** A buff type marking that a given column/component must be included in every query against the table, using
	  * the value provided by the buff. It implies `NoSelect` and `NoQuery` and is used to artificially limit the number
	  * of mapped entities. */
	case object ExtraQuery extends ComboBuffType(NoSelect, NoQuery) with GeneratedBuffType

	/** Marks that a column/component ''must'' be included as part of the where clause of any update statement. */
	case object ForcedQuery extends FlagBuff


	/** A buff marking that a given column/component can be omitted from the insert statement.
	  * It is still included by default and needs to be excluded explicitly. */
	case object OptionalInsert extends FlagBuff

	/** A buff marking that a given column/component is not inserted by default into the underlying table
	  * and needs to be included explicitly. It implies `OptionalInsert` and `NoInsertByDefault`. */
	case object ExplicitInsert extends ComboFlag(OptionalInsert, NoInsertByDefault)

	/** Marks a column/component as having its value initialized by the expression provided by the buff
	  * rather than the entity. Used particularly for 'created on' or 'created by' type of columns. */
	case object ExtraInsert extends ComboBuffType(NoInsert) with GeneratedBuffType



	/** A buff marking that a given column/component can be omitted from the update statement.
	  * It is still included by default and needs to be excluded explicitly. */
	case object OptionalUpdate extends FlagBuff

	/** A buff marking that a given column/component is not included by default in the update statements
	  * and needs to be included explicitly. It implies `OptionalUpdate` and `NoUpdateByDefault`. */
	case object ExplicitUpdate extends ComboFlag(OptionalUpdate, NoUpdateByDefault)

	/** Marks a column/component as being updated with the value of the expression provided by the buff
	  * rather than some property of the mapped entity. Useful for particularly for 'update timestamp' columns. */
	case object ExtraUpdate extends ComboBuffType(NoUpdate) with GeneratedBuffType



	/** Marks a column/component as not mandatory for insert and update statements. */
	case object OptionalWrite extends ComboFlag(OptionalInsert, OptionalUpdate)

	/** Marks a column/component as not included in the insert/update statements by default and needing to be included explicitly. */
	case object ExplicitWrite extends ComboFlag(ExplicitInsert, ExplicitUpdate, OptionalWrite)

	/** Marks a column/component as having its value set by this buff rather than a property of the entity
	  * at every write to the database. Implies `ExtraInsert` and `ExtraUpdate`. */
	case object ExtraWrite extends ComboBuffType(ExtraInsert, ExtraUpdate) with GeneratedBuffType



	/** Any value returned from the select (or assembled from such values) of a column/component annotated
	  * with this buff type must be mapped with the function included in the buff. This buff is independent
	  * from buffs specifying whether and when a component can be included in a select header. */
	case object SelectAudit extends SubstituteBuffType

	case object QueryAudit extends SubstituteBuffType

	/** All values of columns/components annotated with this buff type must be mapped with the function
	  * included in the buff before inserting the entity declaring it. This does not include update statements
	  * and is independent of any buffs specifying if the column/component can be inserted at all. */
	case object InsertAudit extends SubstituteBuffType

	/** All values of columns/components annotated with this buff type must be mapped with the function
	  * included in the buff before updating the entity declaring it. This does not include insert statements
	  * and is independent of any buffs specifying if the column/component can be updated at all. */
	case object UpdateAudit extends SubstituteBuffType

	/** All values of columns/components annotated with this buff type must be mapped with the function
	  * included in the buff before inserting or updating the entity declaring it.
	  * This is independent of any buffs specifying if the column/component can be inserted at all. */
	case object WriteAudit extends ComboBuffType(UpdateAudit, InsertAudit) with SubstituteBuffType



	/** A flag signifying that mapped values can be null. */
	case object Nullable extends FlagBuff //todo:





/*
	/** A mapping buff marking a given component as a sym link to another component under the root mapping.
	  * The value for this component is set as the value of the component at the end of the path and is never
	  * written to the database, leaving that responsibility to the linked component.
	  */
	case class SymLink[X <: SingletonMapping, Y <: TypedSingleton[T], T, V] private
			(target :TypedComponentPath[X, Y, T], value :T=>V)
		extends Buff[V]
	{
		override def map[O](there: V => O): Buff[O] = new SymLink(target, value andThen there)

		def startingWith[M <: SingletonMapping](mapping :M) :Option[SymLink[M, Y, T, V]] =
			this.asInstanceOf[SymLink[M, Y, T, V]].providing(target.start==mapping)


		override def factory: BuffType = SymLink
	}

	object SymLink extends BuffType {
		def apply[X<:SingletonMapping, Y <: TypedSingleton[T], T](path :TypedComponentPath[X, Y, T]) :SymLink[X, Y, T, T] =
			new SymLink(path, identity[T])

		def apply[T](mapping :AnyMapping)(target :mapping.Component[T]) :SymLink[mapping.type, target.type, T, T] =
			new SymLink[mapping.type, target.type, T, T](mapping \\ target, identity[T])

		override def test[T](buff: Buff[T]): Option[SymLink[_<:AnyMapping, _<:AnyMapping, _, T]] =
			buff.asSubclass[SymLink[_<:AnyMapping, _<:AnyMapping, _, T]]

		def startsWith[M <: SingletonMapping, T](mapping :M)(component :mapping.Component[T])
				:Option[SymLink[M, _ <: TypedSingleton[X], X, T] forSome { type X }]  =
			component.buffs.toStream.flatMap(startsWith(mapping, _)).headOption //.asInstanceOf[SymLink[M, Mapping[Any], Any, T]]

		def startsWith[M <: SingletonMapping, T](mapping :M, buff :Buff[T])
				:Option[SymLink[M, _ <: TypedSingleton[X], X, T] forSome { type X }] =
			buff match {
				case sl :SymLink[_,_,_,_] if sl.target.start == mapping =>
					Some(sl.asInstanceOf[SymLink[M, TypedSingleton[Any], Any, T]])
				case _ => None
			}

	}
*/

	/** A buff type marking that a column contains an application generated timestamp set once, when the row is inserted.
	  * It is an `ExtraInsert` buff, meaning it will be automatically included in every insert and the value present
	  * in the inserted entity will be ignored.
	  * It should be of a type with a provided [[net.noresttherein.oldsql.schema.bits.Temporal Temporal]] type class.
	  */
	case object CreateTimestamp extends ComboBuffType(ExtraInsert) with GeneratedBuffType {
		def apply[T :Temporal]() :GeneratedBuff[T] = apply(implicitly[Temporal[T]].now())
	}

	/** A buff type marking that a column contains an application generated timestamp set when the row is inserted
	  * and every time it is updated. It implies `CreateTimestamp`, `ExtraInsert` and `ExtraUpdate`, meaning it will
	  * be automatically included in every write of the mapped entity to the database and the value present in the
	  * entity will be ignored.
	  * It should be of a type with a provided [[net.noresttherein.oldsql.schema.bits.Temporal Temporal]] type class.
	  */
	case object UpdateTimestamp extends ComboBuffType(ReadOnly, ExtraUpdate, CreateTimestamp) with GeneratedBuffType {
		def apply[T :Temporal]() :GeneratedBuff[T] = apply(implicitly[Temporal[T]].now())
	}

	/** A buff type marking that a column serves as a timestamp-based optimistic lock.
	  * It is the same as [[net.noresttherein.oldsql.schema.Buff.UpdateTimestamp UpdateTimestamp]], but also
	  * implies [[net.noresttherein.oldsql.schema.Buff.ForcedQuery ForcedQuery]]. This means the values
	  * carried by entities will be ignored during the update and instead a fresh timestamp will be used as the new
	  * value ''and'' the old value must be included in the 'where' clause of the update statement to prevent
	  * overwriting a concurrent update.
	  * Note that the value of the column can, strictly speaking, be of any type not related to time, as long as
	  * an implicit instance of the [[net.noresttherein.oldsql.schema.bits.Temporal Temporal]] type class is provided
	  * for it.
	  */
	case object UpdateLock extends ComboBuffType(UpdateTimestamp, ForcedQuery) with GeneratedBuffType {
		def apply[T :Temporal]() :GeneratedBuff[T] = apply(implicitly[Temporal[T]].now())
	}

	/** Marks a column/component as carrying a 'version' stamp used to implement optimistic locking. The value of
	  * carried by the entity is automatically increased/modified during the update, but the old value is used
	  * as part of the 'where' clause to prevent overwriting a concurrent update.
	  */
	case object Version extends ComboBuffType(ReadOnly, ExtraInsert, UpdateAudit, ForcedQuery) with ManagedBuffType {
		def apply[T]()(implicit int :Integral[T]) :ManagedBuff[T] =
			apply(int.fromInt(0), int.plus(_, int.fromInt(1)))

		def apply[T](init :T)(implicit int :Integral[T]) :ManagedBuff[T] =
			apply(init, int.plus(_, int.fromInt(1)))
	}






	/** A 'class for classes' being subtypes of `Buff`. Serves as a factory and matcher for a type of `Buff`,
	  * a witness grouping related buffs and providing information about implication relations between various buffs.
	  */
	trait BuffType { factory =>
		def implies(other :BuffType) :Boolean = other == this

		object Enabled extends ColumnFilter.WithBuff(factory) {
			@inline def unapply(buff :Buff[_]) :Boolean = enabled(buff)
			@inline def unapply(buffs :Seq[Buff[_]]) :Boolean = enabled(buffs)
			@inline def unapply(mapping :AnyMapping) :Boolean = enabled(mapping)
		}
		object Disabled extends ColumnFilter.WithoutBuff(factory) {
			@inline def unapply(buff :Buff[_]) :Boolean = disabled(buff)
			@inline def unapply(buffs :Seq[Buff[_]]) :Boolean = disabled(buffs)
			@inline def unapply(mapping :AnyMapping) :Boolean = disabled(mapping)
		}

		def enabled(buff :Buff[_]) :Boolean = buff is this //test(buff).isDefined
		def enabled(buffs :Seq[Buff[_]]) :Boolean = buffs.exists(enabled)
		def enabled(column :AnyMapping) :Boolean = enabled(column.buffs)

		def disabled(buff :Buff[_]) :Boolean = !(buff is this) //test(buff).isEmpty
		def disabled(buffs :Seq[Buff[_]]) :Boolean = buffs.forall(disabled)
		def disabled(column :AnyMapping) :Boolean = disabled(column.buffs)

		def test[T](buff :Buff[T]) :Option[Buff[T]] = buff is this ifTrue buff
		def test[T](buffs :Seq[Buff[T]]) :Option[Buff[T]] =
			buffs.collectFirst { case buff if buff is this => buff }
		def test[T](column :TypedMapping[T]) :Option[Buff[T]] = test(column.buffs)


		override val toString :String = this.innerClassName

	}



	
	/** A scaffolding base trait for buff types which use a `Buff` subclass rather then the `Buff` class itself. */
	sealed trait DedicatedBuffType[+B[T] <: Buff[T]] extends BuffType {
		private[this] val Class :ClassTag[B[Any]] = classTag.asInstanceOf[ClassTag[B[Any]]]
		protected[this] def classTag :ClassTag[_]

		override def test[T](buff :Buff[T]) :Option[B[T]] = buff match {
			case Class(b) if b is this => Some(b.asInstanceOf[B[T]])
			case _ => None
		}

		override def test[T](buffs :Seq[Buff[T]]) :Option[B[T]] =
			buffs collectFirst { case Class(b) if b is this => b.asInstanceOf[B[T]] }

		override def test[T](column :TypedMapping[T]) :Option[B[T]] = test(column.buffs)

		def unapply[T](buff :Buff[T]) :Option[B[T]] = test(buff)

		def unapply[T](buffs :Seq[Buff[T]]) :Option[B[T]] = test(buffs)

		def unapply[T](column :TypedMapping[T]) :Option[B[T]] = test(column)
	}






	/** A `Buff` type which doesn't have any `Buff` instances, but is instead implied by other buff types. */
	class AbstractBuffType extends BuffType

	/** A `Buff` type which doesn't have any `Buff` instances and won't match any of them. */
	object AbstractBuff extends AbstractBuffType {
		override def test[T](buff :Buff[T]) :Option[Buff[T]] = None
		override def test[T](buffs :Seq[Buff[T]]) :Option[Buff[T]] = None
	}






	/** A simple mapping buff which doesn't perform any function in the mapping itself, but serves
	  * instead as a switch checked at certain points to modify the behaviour of the annotated component,
	  * such as including an extra column in the update.
	  */
	trait FlagBuff extends Buff[Nothing] with BuffType {
		override def factory :BuffType = this

		override def map[X](there: Nothing => X): FlagBuff = this

		override def is(buff :BuffType) :Boolean = implies(buff)

		@inline final def unapply[T](buff :Buff[T]) :Boolean = enabled(buff)
		@inline final def unapply[T](buffs :Seq[Buff[T]]) :Boolean = enabled(buffs)
		@inline final def unapply[T](component :Mapping[T]) :Boolean = enabled(component)

		override def canEqual(that :Any) :Boolean = that.isInstanceOf[FlagBuff]

		override def equals(that :Any) :Boolean = that match {
			case ref :AnyRef => ref eq this
			case _ => false
		}

		override def hashCode :Int = System.identityHashCode(this)

	}



	object BuffFlag {
		/** Creates a new, unique type of component flag using the given name as the identifier. */
		def apply(name :String) :FlagBuff = new NamedFlag(name)

		private class NamedFlag(override val toString :String) extends FlagBuff {

			override def canEqual(that :Any) :Boolean = that.isInstanceOf[NamedFlag]

			override def equals(that :Any) :Boolean = that match {
				case flag :NamedFlag => (flag eq this) || flag.toString == toString
				case _ => false
			}

			override def hashCode :Int = toString.hashCode
		}
	}



	/** A `Buff` type which implies other, more general buffs (has strictly more specific implications).
	  * Attaching a `Buff` of this type to a component is roughly equivalent to attaching buffs of the types
	  * listed in the constructor.
	  */
	class ComboBuffType(val implied :BuffType*) extends BuffType {
		override def implies(other: BuffType): Boolean =
			other == this || implied.exists(_.implies(other))

		override def test[T](option: Buff[T]): Option[Buff[T]] =
			option.providing(option.is(this))
	}



	/** A `BuffFlag` which implies other flags (is equivalent to having them declared alongside it). */
	class ComboFlag(implied :BuffType*) extends ComboBuffType(implied:_*) with FlagBuff {
		override def implies(other :BuffType) :Boolean = super[ComboBuffType].implies(other)
	}






	/** A `Buff` which carries a value. These values are generally used instead of the the value carried
	  * by an entity or read from the database, but the exact handling depends on the buff type.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuffType]]
	  */
	trait ValuedBuff[+T] extends Buff[T] {
		override def map[X](there :T => X) :ValuedBuff[X]

		def value :T

		def factory :ValuedBuffType
	}


	object ValuedBuff {
		def unapply[T](buff :Buff[T]) :Option[T] = buff match {
			case const :ValuedBuff[T] => Some(const.value)
			case _ => None
		}

		def unapply[T](buffs :Seq[Buff[T]]) :Option[T] =
			buffs collectFirst { case const :ValuedBuff[T] => const.value }

		@inline def unapply[T](column :TypedMapping[T]) :Option[T] = unapply(column.buffs)
	}



	/** A `Buff` type which carries a value. These buff types are handled explicitly when creating and executing
	  * individual SQL statements. Which statements are affected (and how the value is used) depends on which
	  * of the `ValuedBuffType` instances are implied by the implementing class:
	  *   - implying `ExtraSelect` means the annotated component is never included in the select header and the
	  *     value provided by the buff is used instead;
	  *   - implying `ExtraQuery` means that every select and update statement must include the annotated component
	  *     in the 'where' clause to additionally filter the set of rows mapped by the application;
	  *   - implying `ExtraInsert` means that buff's value is used instead of any value carried by the entity
	  *     when inserting a new row into the database;
	  *   - implying `ExtraUpdate` means that buff's value is used instead of any value carried by the entity
	  *     when updating a row in the database.
	  *  As always, extending classes can imply several of the above at the same time.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuff]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ExtraSelect]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ExtraQuery]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ExtraInsert]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ExtraUpdate]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ExtraWrite]]
	  */
	trait ValuedBuffType extends DedicatedBuffType[ValuedBuff] {
		protected[this] def classTag :ClassTag[_] = implicitly[ClassTag[ValuedBuff[Any]]]

		object Value {
			@inline def unapply[T](option :Buff[T]) :Option[T] = test(option).map(_.value)
			@inline def unapply[T](options :Seq[Buff[T]]) :Option[T] = test(options).map(_.value)
			@inline def unapply[T](mapping :TypedMapping[T]) :Option[T] = test(mapping).map(_.value)

			@inline def apply[T](option :Buff[T]) :Option[T] = unapply(option)
			@inline def apply[T](options :Seq[Buff[T]]) :Option[T] = unapply(options)
			@inline def apply[T](mapping :TypedMapping[T]) :Option[T] = unapply(mapping)

		}

	}



	/** A `Buff` type without any instances, not applied to any components. */
	case object AbstractValuedBuff extends ValuedBuffType {
		override def test[T](buff :Buff[T]) :Option[ValuedBuff[T]] = None
		override def test[T](buffs :Seq[Buff[T]]) :Option[ValuedBuff[T]] = None
	}



	/** A mapping buff which carries a constant value to be used instead of the value present in the entity or
	  * the database, depending on the exact buff type.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuffType]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ConstantBuffType]]
	  */
	class ConstantBuff[+T](val factory :ConstantBuffType, val value :T) extends ValuedBuff[T] {

		override def map[X](there: T => X): ConstantBuff[X] = factory(there(value))

		override def equals(that: Any): Boolean = that match {
			case o :ConstantBuff[_] => (o eq this) || o.canEqual(this) && o.value==value && o.factory == factory
			case _ => false
		}


		override def toString = s"$factory: $value"
	}
	
	object ConstantBuff {
		def unapply[T](buff :Buff[T]) :Option[T] = buff match {
			case const :ConstantBuff[T] => Some(const.value)
			case _ => None
		}
		
		def unapply[T](buffs :Seq[Buff[T]]) :Option[T] =
			buffs collectFirst { case const :ConstantBuff[T] => const.value }
		
		@inline def unapply[T](column :TypedMapping[T]) :Option[T] = unapply(column.buffs) 
	}



	/** A base trait for factories of `Buff[T]` instances wrapping values of `T`.
	  * By implying one of the predefined `ExtraSelect`, `ExtraQuery`, `ExtraInsert`, `ExtraUpdate` buff types,
	  * extending classes specify when (with which statement types) these values should be used.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuffType]]
	  */
	trait ConstantBuffType extends ValuedBuffType {
		def apply[T](value :T) :ConstantBuff[T] = new ConstantBuff[T](this, value)
	}



	/** A buff which reevaluates encapsulated expression each time its `value` method is called.
	  * This is similar to `ConstantBuff`, but the value is reevaluated with each call to `this.value`.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuffType]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.GeneratedBuffType]]
	  */
	class GeneratedBuff[+T](val factory :GeneratedBuffType, generator: =>T) extends ValuedBuff[T] {
		def value :T = generator

		override def map[X](there :T => X) :GeneratedBuff[X] = factory(there(generator))

		override def equals(that :Any) :Boolean = that match {
			case ref :AnyRef if ref eq this => true
			case _ => false
		}

		override def hashCode :Int = System.identityHashCode(this)

		override def toString :String = "=>" + factory
	}


	object GeneratedBuff {
		def unapply[T](buff :Buff[T]) :Option[T] = buff match {
			case const :GeneratedBuff[T] => Some(const.value)
			case _ => None
		}

		def unapply[T](buffs :Seq[Buff[T]]) :Option[T] =
			buffs collectFirst { case const :GeneratedBuff[T] => const.value }

		@inline def unapply[T](column :TypedMapping[T]) :Option[T] = unapply(column.buffs)
	}


	
	/** A column/component `Buff` type which carries a by-name value. This value is used instead of the value
	  * present in the entity or the database in SQL statements. Which statements are affected depends on which
	  * of the predefined `ExtraSelect`, `ExtraQuery`, `ExtraInsert`, `ExtraUpdate` buffs is implied by the
	  * extending class. It is similar to `ConstantBuffType`, but the value provided by the buff is re-evaluated
	  * at each access.
	  * @see [[net.noresttherein.oldsql.schema.Buff.GeneratedBuff]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ValuedBuffType]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.ConstantBuffType]]
	  */
	trait GeneratedBuffType extends ValuedBuffType {
		/** Create a `Buff` which will reevaluate the given expression each time its `value` method is accessed. */
		def apply[T](value: =>T) :GeneratedBuff[T] = new GeneratedBuff(this, value)
	}


	/** A column/component `Buff` carrying a function `T=>T` which is used to modify the value read or written
	  * to the database. Which operations are actually affected depends on the buff type.
	  */
	class SubstituteBuff[T](val factory :SubstituteBuffType, val substitute :T => T) extends Buff[T] {
		override def map[X](there :T => X) :Nothing =
			throw new UnsupportedOperationException(this +".map: SubstituteBuff can't be mapped unidirectionally.")

		def map[X](there :T => X, back :X => T) :SubstituteBuff[X] =
			new SubstituteBuff[X](factory, back andThen substitute andThen there)

		override def equals(that :Any) :Boolean = that match {
			case sub :SubstituteBuff[_] => (sub eq this) || sub.factory == factory && sub.substitute == substitute
			case _ => false
		}

		override def hashCode :Int = factory.hashCode * 31 + substitute.hashCode

		override def toString :String = factory + "(" + substitute + ")"
	}



	/** A buff type which inspects and possibly modifies the value of the annotated column/component during
	  * a database operation. Exactly which operation(s) is/are affected is determined declaratively by
	  * implying one of the 'audit' types: `SelectAudit`, `QueryAudit`, `InsertAudit`, `UpdateAudit`.
	  * @see [[net.noresttherein.oldsql.schema.Buff.SelectAudit]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.QueryAudit]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.InsertAudit]]
	  * @see [[net.noresttherein.oldsql.schema.Buff.UpdateAudit]]
	  */
	trait SubstituteBuffType extends DedicatedBuffType[SubstituteBuff] { self =>
		protected[this] override  def classTag :ClassTag[_] = implicitly[ClassTag[SubstituteBuff[Any]]]


		protected def apply[T](map :T => T) :SubstituteBuff[T] = new SubstituteBuff(this, map)

		object Audit {
			@inline def apply[T](buff :Buff[T]) :Option[T=>T] = unapply(buff)
			@inline def apply[T](buffs :Seq[Buff[T]]) :Seq[T=>T] = unapply(buffs)
			@inline def apply[T](buffs :TypedMapping[T]) :Seq[T=>T] = unapply(buffs)
			
			def unapply[T](buff :Buff[T]) :Option[T=>T] = buff match {
				case sub :SubstituteBuff[T] if sub is self => Some(sub.substitute)
				case _ => None
			}
			
			def unapply[T](buffs :Seq[Buff[T]]) :Seq[T => T] =
				buffs collect { case sub :SubstituteBuff[T] if sub is self => sub.substitute }
			
			def unapply[T](column :TypedMapping[T]) :Seq[T => T] = unapply(column.buffs) 
		}
	}





	/** A `ManagedBuff` is a combination of a `ValuedBuff` and `SubstituteBuff`, carrying both a by-name value
	  * and inspection/scanning function. When each of these is used depends, as always, on the associated buff type.
	  * This choice is made by implying one of the predefined 'audit' buff types: `SelectAudit`, `QueryAudit`,
	  * `InsertAudit` and `UpdateAudit`.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ManagedBuffType]]
	  */
	class ManagedBuff[T](override val factory :ManagedBuffType, init: =>T, update :T => T)
		extends SubstituteBuff[T](factory, update) with ValuedBuff[T]
	{
		override def value :T = init

		override def map[X](there :T => X) :Nothing =
			throw new UnsupportedOperationException(this +".map: ManagedBuff can't be mapped unidirectionally.")

		override def map[X](there :T => X, back :X => T) :ManagedBuff[X] =
			new ManagedBuff(factory, there(init), back andThen substitute andThen there)

		override def equals(that :Any) :Boolean = that match {
			case self :AnyRef => this eq self
			case _ => false //won't happen
		}

		override def hashCode :Int = System.identityHashCode(this)

		override def toString :String = factory + "(?, " + substitute + ")"
	}



	/** A `ManagedBuffType` is a combination of a `ValuedBuffType` and `SubstituteBuffType`, with the intention
	  * of using one for some types of SQL statements and the other for other types. Most typically this means
	  * using a generated value for insert and a modified value for update statements, but any combination
	  * is possible as long as the sets of affected statements are disjoint. This selection is made, as with
	  * the base types, by implying some subset of `ExtraSelect`, `ExtraQuery`, `ExtraInsert`, `ExtraUpdate`,
	  * `SelectAudit`, `QueryAudit`, `InsertAudit`, `UpdateAudit`.
	  * @see [[net.noresttherein.oldsql.schema.Buff.ManagedBuff]]
	  */
	trait ManagedBuffType extends ValuedBuffType with SubstituteBuffType with DedicatedBuffType[ManagedBuff] {
		protected[this] override def classTag :ClassTag[_] = implicitly[ClassTag[ManagedBuff[Any]]]

		override protected def apply[T](map :T => T) :SubstituteBuff[T] =
			throw new UnsupportedOperationException(
				this + ".apply(" + map + "): ManagedBuffType requires an initial value; use the two-argument constructor."
			)

		def apply[T](init: =>T, update :T => T) :ManagedBuff[T] = new ManagedBuff(this, init, update)

	}
}
