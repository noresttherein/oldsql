package net.noresttherein.oldsql.schema

import java.sql.ResultSet

import net.noresttherein.oldsql.collection.InverseIndexSeq
import net.noresttherein.oldsql.schema.Mapping.{ColumnFilter, Buff, MappingReadForm}
import net.noresttherein.oldsql.schema.Mapping.Buff.{ExplicitSelect, BuffType, NoInsert, NoQuery, NoSelect, NoUpdate, SymLink}
import net.noresttherein.oldsql.collection.InverseIndexSeq.implicitIndexing
import net.noresttherein.oldsql.schema.SQLForm.EmptyForm
import net.noresttherein.oldsql.schema.support.MappedMapping
import net.noresttherein.oldsql.schema.support.MappedMapping.MappedAs
import net.noresttherein.oldsql.schema.ComponentPath.TypedComponentPath
import net.noresttherein.oldsql.slang._
import net.noresttherein.oldsql.slang.SaferCasts._


/** Root interface of the  mapping class hierarchy to be used when the mapped type is of little importance (for example
  * in collections of mappings for various types). All implementations are required to extend `Mapping[T]` instead,
  * which is parameterized with the mapped type. The main reason for this duplicity is the limitation of scala type
  * inference: a generic method `m[M&lt;:Mapping[T], T](m :M)` will infer type parameters `M`, `Nothing` when given
  * an argument of type `M&lt;:Mapping[T]`. On the other hand, when a type parameter is declared `M&lt;:Mapping[_]`,
  * the `Subject` is instantiated early as 'Any' and it is not equal to `m.Subject`, leading to other problems later.
  */
sealed trait AnyMapping { mapping =>
	/** The mapped entity type. */
	type Subject

	/** The mapping which this instance is a part of. This may be the mapping directly enclosing this mapping,
	  * but more typically will be a 'root' mapping, such as a table mapping. The 'Owner' tag is passed down
	  * the components comprising such a mapping in order to identify them as containing columns being part of
	  * the owner mapping, thus adding type safety when creating sql formulas, which can thus enforce that
	  * only components/columns belonging to the selected tables (or otherwise root mappings) can be used
	  * in the where or select clause.
	  */
	type Owner <: AnyMapping

	/** A container with values for components of this mapping required to assemble the subject. */
	type Values = ComponentValues[this.type]


	type AnyComponent = Component[_]
	type Component[T] = Mapping.Component[Owner, T] //<: SubMapping[T, Owner]


	def buffs :Seq[Buff[Subject]]


	def enabled(opt :BuffType) :Boolean = opt.enabled(this)
	def disabled(opt :BuffType) :Boolean = opt.disabled(this)


	def asComponent :Mapping[Subject] with this.type { type Owner = mapping.Owner }

	/** Direct component mappings of this mapping, including any top-level columns. */
	def components :Seq[Component[_]]

	/** All transitive components of this mapping (i.e. components/columns declared by it's components or
	  * other subcomponents), or all that this mapping cares to expose, as instances of this.Component[_].
	  * This list should include all selectable columns.
	  */
	def subcomponents :Seq[Component[_]]

	def columnsFor(filter :ColumnFilter) :Seq[Component[_]]

	/** All direct and transitive columns declared within this mapping. This will include columns which are read-only,
	  * write-only and so on.
	  */
	def columns :Seq[Component[_]]
	/** All columns which can be part of an sql filter (don't have `NoQuery` flag set). */
	def queryable :Seq[Component[_]]
	/** All columns which can be listed in the select clause of an sql. */
	def selectable :Seq[Component[_]]
	/** All columns which can be updated on existing database records. */
	def updatable :Seq[Component[_]]
	/** All columns which can occur in an insert statement. */
	def insertable :Seq[Component[_]]
	/** Columns autogenerated by the database; this implies being non-insertable. */
	def generated :Seq[Component[_]]

	/** All columns with a given option provided */
	protected def columnsWith(buff :BuffType) :InverseIndexSeq[Component[_]] =
		columns.filter(buff.enabled).indexed

	/** All columns without the given option */
	protected def columnsWithout(buff :BuffType) :InverseIndexSeq[Component[_]] =
		columns.filter(buff.disabled).indexed


	/** Read form of a select statement for this mapping including the given components of this mapping. */
	def selectForm(components :Seq[Component[_]]) :SQLReadForm[Subject]

	/** Default read form (included columns) of a select statement for this mapping. */
	def selectForm :SQLReadForm[Subject]

	/** Default write form (included parameters) of a query for this mapping. */ //todo: PK? all?
	def queryForm :SQLWriteForm[Subject]

	/** Default write form (included columns) of update statements for this mapping. */
	def updateForm :SQLWriteForm[Subject]

	/** Default write form (included columns) of insert statements for this mapping. */
	def insertForm :SQLWriteForm[Subject]

	/** A read form containing only the columns of this mapping selected by the given filter. */
	def readForm(filter :ColumnFilter) :SQLReadForm[Subject]

	/** A write form containing only the columns of this mapping selected by the given filter. */
	def writeForm(filter :ColumnFilter) :SQLWriteForm[Subject]



	def apply(values: Values): Subject /*=
		optionally(values) getOrElse {
			throw new IllegalArgumentException(s"Can't assemble $this from $values")
		}*/

	def optionally(values: Values): Option[Subject] /*=
		values.result(this) orElse ExplicitSelect.Value(this)*/

	def assemble(values :Values) :Option[Subject]

	def nullValue :Option[Subject]



	def sqlName :Option[String] = None

	def isSymLink[T](component :Component[T]) :Boolean = symLinkTarget(component).isDefined

	def symLinkTarget[T](component :Component[T]) :Option[ComponentPath[this.type, _<:AnyMapping]] =
		SymLink.startsWith[this.type, T](this :this.type)(component).map(_.target)



	def apply[T](component :Component[T], value :Subject) :T = {
		val path = this \\ component
		path.surepick.map(_(value)) orElse path.pick(value) getOrElse {
			throw new IllegalArgumentException(s"Can't get value for $component from $value of $this")
		}
	}

//	def apply[C<:AnyComponent](component :this.type=>C) :ComponentPath[this.type, C]

	implicit def \\ [X](component :Component[X]) :TypedComponentPath[this.type, component.type, X]

	def qualified(prefix :String) :Component[Subject] /*=
		Mapping.prefixOption(prefix).map(new QualifiedMapping[Subject](this, _)) getOrElse this*/

	def prefixed(prefix :String) :Component[Subject] /*=
		Mapping.prefixOption(prefix).map(new PrefixedMapping[Subject, this.type](this, _)) getOrElse this*/


	def map[X](there :Subject=>X, back :X=>Subject) :this.type MappedAs X =
		MappedMapping[this.type, Subject, X](this, there, back)


	override def toString :String = sqlName getOrElse this.unqualifiedClassName

	def introString :String = columns.mkString(this+"{", ",", "}")

}






trait Mapping[S] extends AnyMapping { self =>

	type Subject = S

	def buffs :Seq[Buff[S]] = Seq()

	override def columnsFor(filter :ColumnFilter) :Seq[Component[_]] = filter(this :this.type)

	def selectForm(components :Seq[Component[_]]) :SQLReadForm[S] =
		MappingReadForm[S](this :this.type)(this.selectable, _.selectForm)
	def selectForm :SQLReadForm[S]
	def queryForm :SQLWriteForm[S]
	def updateForm :SQLWriteForm[S]
	def insertForm :SQLWriteForm[S]

	def writeForm(filter :ColumnFilter) :SQLWriteForm[S] = filter.write(this)
	def readForm(filter :ColumnFilter) :SQLReadForm[S] = filter.read(this)



	override def apply(values: Values): S =
		optionally(values) getOrElse {
			throw new IllegalArgumentException(s"Can't assemble $this from $values")
		}

	override def optionally(values: Values): Option[S] =
		values.result(this) orElse ExplicitSelect.Value(this)

	def assemble(values :Values) :Option[S]

	def nullValue :Option[S] = None




//	def qualified(prefix :String) :Mapping[S, O] =
//		Mapping.prefixOption(prefix).map(new QualifiedMapping[S](this, _)) getOrElse this
//
//	def prefixed(prefix :String) :Mapping[S, O] =
//		Mapping.prefixOption(prefix).map(new PrefixedMapping[S, this.type](this, _)) getOrElse this

}



trait SubMapping[O <: AnyMapping, S] extends Mapping[S] {
	type Owner = O
//	type Component[X] = SubMapping[X, O]

	override final def asComponent :this.type = this

}



trait RootMapping[S] extends Mapping[S] {
	type Owner = this.type
//	type Component[X] = SubMapping[S, this.type]

	override final def asComponent :this.type = this
}






object Mapping {
	type TypedMapping[S] = AnyMapping { type Subject = S }
//	type Component[S, O] = AnyMapping { type Subject=S; type Parent=O }
//	type AnyComponent[O] = AnyMapping { type Parent=O }
	type AnyComponent[O <: AnyMapping] = Component[O, _]
	type Component[O <: AnyMapping, S] = Mapping[S] { type Owner = O }//AnyMapping { type Subject = S; type Owner = O }

	type SingletonMapping = AnyMapping with Singleton
	type TypedSingleton[S] = AnyMapping with Singleton { type Subject = S }
	type SingletonComponent[O <: AnyMapping, S] = Mapping[S] with Singleton { type Owner = O } //AnyMapping with Singleton { type Subject = S; type Owner = O }


	type ComponentCompatibleMapping[M <: AnyMapping] = AnyMapping {
		type Component[X] = Mapping.Component[M#Owner, X]
	}

	type CompatibleMapping[M <: AnyMapping] = AnyMapping {
		type Owner = M#Owner
		type Subject = M#Subject
		type Component[X] = M#Component[X] //SubMapping[X, M]
	}

	type TypeCompatibleMapping[M<:AnyMapping] = AnyMapping {
		type Subject = M#Subject
	}






	trait ColumnFilter {
		def apply[E](mapping :Mapping[E]) :Seq[mapping.Component[_]] =
			mapping.columns.filter(c => apply(mapping :mapping.type, c))

		def apply[M<:AnyMapping, T](mapping :M, column :M#Component[T]) :Boolean

		def read[E](mapping :Mapping[E]) :SQLReadForm[E] =
			MappingReadForm(mapping :mapping.type)(apply(mapping :mapping.type), read(_))

		def write[E](mapping :Mapping[E]) :SQLWriteForm[E] =
			MappingWriteForm(mapping :mapping.type)(apply(mapping :mapping.type), write(_))
	}



	object ColumnFilter {
		class WithBuff(buff :BuffType) extends ColumnFilter {
			def apply[M<:AnyMapping, T](mapping :M, column :M#Component[T]): Boolean =
				buff.enabled(column)
		}
		class WithoutBuff(buff :BuffType) extends ColumnFilter {
			def apply[M<:AnyMapping, T](mapping :M, column :M#Component[T]): Boolean =
				buff.disabled(column)
		}
		class WriteFilter(modifier :BuffType) extends WithoutBuff(modifier) {
			override def read[E](mapping: Mapping[E]) =
				EmptyForm(throw new UnsupportedOperationException(s"$this: read for $mapping"))
		}

		case object ForSelect extends WithoutBuff(NoSelect) {
			override def apply[E](mapping: Mapping[E]) :Seq[mapping.Component[_]] = mapping.selectable
			override def read[E](mapping: Mapping[E]) :SQLReadForm[E] = mapping.selectForm
			override def write[E](mapping: Mapping[E]) :SQLWriteForm[Any] = SQLWriteForm.empty
		}

		case object ForQuery extends WriteFilter(NoQuery) {
			override def apply[E](mapping :Mapping[E]) :Seq[mapping.Component[_]] = mapping.queryable
			override def write[E](mapping :Mapping[E]) :SQLWriteForm[E] = mapping.queryForm
		}

		case object ForInsert extends WriteFilter(NoInsert) {
			override def apply[E](mapping: Mapping[E]) :Seq[mapping.Component[_]] = mapping.insertable
			override def write[E](mapping: Mapping[E]) :SQLWriteForm[E] = mapping.insertForm
		}

		case object ForUpdate extends WriteFilter(NoUpdate) {
			override def apply[E](mapping :Mapping[E]) :Seq[mapping.Component[_]] = mapping.updatable
			override def write[E](mapping :Mapping[E]) :SQLWriteForm[E] = mapping.updateForm
		}

		case object AllColumns extends ColumnFilter {
			override def apply[E](mapping :Mapping[E]) :Seq[mapping.Component[_]] = mapping.columns
			override def apply[M<:AnyMapping, T](mapping :M, column :M#Component[T]) = true
		}
	}






	/** An optional annotation/modifier for component mappings, especially columns.
	  * Modifies the way the annotated component is mapped, in particular it is used to include or exclude
	  * certain columns from select/insert/update statements.
	  * @tparam T the value type of the annotated component.
	  */
	trait Buff[+T] {

		/** Does this buff belong to the buff group defined by `group`, carrying information defined by the group?
		  * this will be true if this buff was created by this group or if the group which created this buff
		  * has strictly stricter meaning than the passed argument, effectively implying the latter.
		  */
		def is(group :BuffType) :Boolean = factory.implies(group)

		def map[X](there :T=>X) :Buff[X]

		protected[Buff] def factory :BuffType


		def canEqual(that :Any) :Boolean = that.getClass == this.getClass

		override def equals(that :Any) :Boolean = that match {
			case o:Buff[_] => (this eq o) || o.canEqual(this) && factory == o.factory
			case _ => false
		}

		override def hashCode :Int = getClass.hashCode

	}



	object Buff {
		/** This column/component is not included in the default select statement and must be specified explicitly,
		  * if at all possible. */
		case object NoSelectByDefault extends AbstractBuffType

		/** This column/component is not included in the default insert statement and must be specified explicitly,
		  * if at all possible. */
		case object NoInsertByDefault extends AbstractBuffType

		/** This column/component is not included in the default update statement and must be specified explicitly,
		  * if at all possible. */
		case object NoUpdateByDefault extends AbstractBuffType

		/** This column/component is not included as the parameter of the default query statement searching for
		  * an equal entity and must be specified explicitly, if at all possible. */
		case object NoQueryByDefault extends AbstractBuffType



		/** This column/component can't be included in a select statement (as part of its header). */
		case object NoSelect extends ComboFlag(NoSelectByDefault)
		/** This column/component can't be included in an insert statement (as the inserted column). */
		case object NoInsert extends ComboFlag(NoInsertByDefault)
		/** This column/component can't be included in an update statement (as the updated column). */
		case object NoUpdate extends ComboFlag(NoUpdateByDefault)
		/** This column/component can't be included as a parameter of a query statement. */
		case object NoQuery extends ComboFlag(NoQueryByDefault)

		/** This column/component is never written to the database by the application. */
		case object ReadOnly extends ComboFlag(NoInsert, NoUpdate)

		/** The value for this column/component is generated by the database on insert and should be returned by the
		  * insert statement. */
		case object AutoGen extends ComboFlag(ReadOnly)

		/** A factory for buffs marking that a given column/component can be omit from the select clause.
		  * It is still included by default and needs to be excluded explicitly. Created values carry a placeholder
		  * value to assign to the annotated component on assembly. */
		case object OptionalSelect extends ValuedBuffType

		/** A factory for buffs marking that a given column/component is omit by default from the select clause
		  * and needs to be included explicitly. When not included, the value stored in the buff will be used
		  * as the value for the annotated component. It implies `OptionalSelect` and `NoSelectByDefault`. */
		case object ExplicitSelect extends ComboBuffType(OptionalSelect, NoSelectByDefault) with ValuedBuffType

		/** A buff marking that a given column/component can be omit from the insert statement.
		  * It is still included by default and needs to be excluded explicitly. */
		case object OptionalInsert extends FlagBuff

		/** A buff marking that a given column/component is not inserted by default into the underlying table
		  * and needs to be included explicitly. It implies `OptionalInsert` and `NoInsertByDefault`. */
		case object ExplicitInsert extends ComboFlag(OptionalInsert, NoInsertByDefault)

		/** A buff marking that a given column/component can be omit from the update statement.
		  * It is still included by default and needs to be excluded explicitly. */
		case object OptionalUpdate extends FlagBuff

		/** A buff marking that a given column/component is not included by default in the update statements
		  * and needs to be included explicitly. It implies `OptionalUpdate` and `NoUpdateByDefault`. */
		case object ExplicitUpdate extends ComboFlag(OptionalUpdate, NoUpdateByDefault)

		/** A buff marking that a given column/component can be omit from the the parameter list of the where
		  * clause of an update statement. It is still included by default and needs to be excluded explicitly. */
		case object OptionalQuery extends FlagBuff

		/** A buff marking that a given column/component can be omit from the parameter list of the where clause
		  * of an update statement and needs to be included explicitly. It implies `OptionalQuery` and `NoQueryByDefault`. */
		case object ExplicitQuery extends ComboFlag(OptionalInsert, NoInsertByDefault)



		/** A mapping buff marking a given component as a sym link to another component under the root mapping.
		  * The value for this component is set as the value of the component at the end of the path and is never
		  * written to the database, leaving that responsibility to the linked component.
		  */
		case class SymLink[X <: SingletonMapping, Y <: TypedSingleton[T], T, V] private (target :TypedComponentPath[X, Y, T], value :T=>V)
			extends Buff[V]
		{
			override def map[O](there: V => O): Buff[O] = new SymLink(target, value andThen there)

			def startingWith[M <: SingletonMapping](mapping :M) :Option[SymLink[M, Y, T, V]] =
				this.asInstanceOf[SymLink[M, Y, T, V]].providing(target.start==mapping)


			override def factory: BuffType = SymLink
		}

		object SymLink extends BuffType {
			def apply[X<:SingletonMapping, Y <: TypedSingleton[T], T](path :TypedComponentPath[X, Y, T]) :SymLink[X, Y, T, T] =
				new SymLink(path, identity[T])

			def apply[T](mapping :AnyMapping)(target :mapping.Component[T]) :SymLink[mapping.type, target.type, T, T] =
				new SymLink[mapping.type, target.type, T, T](mapping \\ target, identity[T])

			override def test[T](buff: Buff[T]): Option[SymLink[_<:AnyMapping, _<:AnyMapping, _, T]] =
				buff.asSubclass[SymLink[_<:AnyMapping, _<:AnyMapping, _, T]]

			def startsWith[M <: SingletonMapping, T](mapping :M)(component :mapping.Component[T]) :Option[SymLink[M, _ <: TypedSingleton[X], X, T] forSome { type X }]  =
				component.buffs.toStream.flatMap(startsWith(mapping, _)).headOption //.asInstanceOf[SymLink[M, Mapping[Any], Any, T]]

			def startsWith[M <: SingletonMapping, T](mapping :M, buff :Buff[T]) :Option[SymLink[M, _ <: TypedSingleton[X], X, T] forSome { type X }] =
				buff match {
					case sl :SymLink[_,_,_,_] if sl.target.start == mapping =>
						Some(sl.asInstanceOf[SymLink[M, TypedSingleton[Any], Any, T]])
					case _ => None
				}

		}






		/** A 'class for classes' being subtypes of `Buff`. Serves as a factory and matcher for a type
		  * of `Buff`, a witness grouping related buffs and providing information about implication
		  * relations between various buffs.
		  */
		trait BuffType {
			def implies(other :BuffType) :Boolean = other==this

			object Enabled {
				def unapply(buff :Buff[_]) :Boolean = enabled(buff)
				def unapply(buffs :Seq[Buff[_]]) :Boolean = enabled(buffs)
				def unapply(mapping :AnyMapping) :Boolean = enabled(mapping)
			}
			object Disabled {
				def unapply(buff :Buff[_]) :Boolean = disabled(buff)
				def unapply(buffs :Seq[Buff[_]]) :Boolean = disabled(buffs)
				def unapply(mapping :AnyMapping) :Boolean = disabled(mapping)
			}

			def enabled(buff :Buff[_]) :Boolean = test(buff).isDefined
			def enabled(buffs :Seq[Buff[_]]) :Boolean = buffs.exists(enabled)
			def enabled(column :AnyMapping) :Boolean = enabled(column.buffs)

			def disabled(buff :Buff[_]) :Boolean = test(buff).isEmpty
			def disabled(buffs :Seq[Buff[_]]) :Boolean = buffs.forall(disabled)
			def disabled(column :AnyMapping) :Boolean = disabled(column.buffs)

			def test[T](buff :Buff[T]) :Option[Buff[T]] //= option.providing(option.is(this))
			def test[T](buffs :Seq[Buff[T]]) :Option[Buff[T]] =
				buffs.map(test[T]).collectFirst{ case Some(x) => x }
			def test[T](column :TypedMapping[T]) :Option[Buff[T]] = test(column.buffs)


			override lazy val toString :String = this.innerClassName

		}

		class AbstractBuffType extends BuffType {
			override def test[T](buff: Buff[T]): Option[Buff[T]] =
				buff.providing(buff.is(this))
		}



		/** A simple mapping buff which doesn't perform any function in the mapping itself, but serves
		  * instead as a switch checked at certain points to modify the behaviour of the annotated component,
		  * such as including an extra column in the update.
		  */
		trait FlagBuff extends Buff[Nothing] with BuffType {
			override def test[T](option: Buff[T]): Option[Buff[T]] =
				option.providing(option.is(this))

			override def factory :BuffType = this

			override def map[X](there: Nothing => X): FlagBuff = this

			override def is(buff :BuffType) :Boolean = implies(buff)

		}


		//todo: add a marker phantom type to denote which BuffType it comes from.
		/** A mapping buff which carries a constant value. */
		class ValuedBuff[+T] private[Buff](val factory :ValuedBuffType, val value :T) extends Buff[T] {

			override def map[X](there: T => X): Buff[X] = factory(there(value))

			override def equals(that: Any): Boolean = that match {
				case o :ValuedBuff[_] => (o eq this) || o.canEqual(this) && o.value==value && o.factory == factory
				case _ => false
			}


			override def toString = s"$factory: $value"

		}



		/** A base trait for factories of `Buff[T]` instances wrapping values of `T`. */
		trait ValuedBuffType extends BuffType {
			def apply[T](value :T) :ValuedBuff[T] = new ValuedBuff[T](this, value)

			override def test[T](option: Buff[T]): Option[ValuedBuff[T]] = option match {
				case v :ValuedBuff[_] if v.is(this) => Some(v.asInstanceOf[ValuedBuff[T]])
				case _ => None
			}

			override def test[T](options: Seq[Buff[T]]): Option[ValuedBuff[T]] =
				options.map(test[T]).collectFirst{ case Some(x) => x }

			override def test[T](mapping: TypedMapping[T]): Option[ValuedBuff[T]] =
				test(mapping.buffs)

			object Value {
				def unapply[T](option :Buff[T]) :Option[T] = test(option).map(_.value)
				def unapply[T](options :Seq[Buff[T]]) :Option[T] = test(options).map(_.value)
				def unapply[T](mapping :TypedMapping[T]) :Option[T] = test(mapping).map(_.value)

				@inline def apply[T](option :Buff[T]) :Option[T] = unapply(option)
				@inline def apply[T](options :Seq[Buff[T]]) :Option[T] = unapply(options)
				@inline def apply[T](mapping :TypedMapping[T]) :Option[T] = unapply(mapping)

			}
		}



		/** A `Buff` instance which implies other, more general buffs (has strictly more specific implications). */
		class ComboBuffType(val implied :BuffType*) extends BuffType {
			override def implies(other: BuffType): Boolean =
				other==this || implied.exists(_.implies(other))

			override def test[T](option: Buff[T]): Option[Buff[T]] =
				option.providing(option.is(this))
		}

		/** A `BuffFlag` which implies other flags (is equivalent to having them declared alongside it). */
		class ComboFlag(implied :BuffType*) extends ComboBuffType(implied:_*) with FlagBuff {
			override def implies(other :BuffType) :Boolean = super[ComboBuffType].implies(other)
		}


	}






	def prefixOption(prefix :String) :Option[String] = prefix.length > 0 ifTrue prefix






	trait MappingReadForm[M <: SingletonMapping] extends SQLReadForm[M#Subject] {
		val mapping :M

		def columns :Seq[AnyComponent[M#Owner]]

		def apply(values :ComponentValues[M]) :M#Subject

		def opt(values :ComponentValues[M]) :Option[M#Subject]

		override def readColumns :Int = columns.size
	}


	class ColumnsReadForm[M <: Mapping[E] with Singleton, E]
			(val mapping :M, read :AnyComponent[M#Owner]=>SQLReadForm[_], val columns :Seq[AnyComponent[M#Owner]])
		extends MappingReadForm[M]
	{
		override def apply(values: ComponentValues[M]): E = values.value(mapping)

		override def opt(values: ComponentValues[M]): Option[E] = values.getValue(mapping)

		override def opt(position: Int)(res: ResultSet): Option[E] = {
			var i = position
			val columnValues = columns map { c => i += 1; read(c).opt(i - 1)(res) }
			val values = ComponentValues(mapping :mapping.type) { comp =>
				val idx = columns.indexOf(comp)
				if (idx >= 0) columnValues(idx)
				else None
			}
			mapping.optionally(values)
		}


		override val readColumns: Int = (0 /: columns)(_ + read(_).readColumns)

		override def nullValue: E = mapping.nullValue getOrElse {
			mapping(ComponentValues(mapping) {
				comp => columns.indexOf(comp).providing(_>=0).map(i => read(columns(i)).nullValue)
			})
		}

		private val mappingString = mapping.sqlName getOrElse mapping.unqualifiedClassName

		override def toString :String = columns.map(read).mkString(s"<$mappingString{", ",", "}")
	}


	object MappingReadForm {

		def apply[E](mapping :Mapping[E])(components :Seq[mapping.Component[_]], form :mapping.Component[_]=>SQLReadForm[_] = _.selectForm) :SQLReadForm[E] =
			new ColumnsReadForm[mapping.type, E](mapping, form, components)

		def selectForm[E](mapping :Mapping[E]) :SQLReadForm[E] =
			apply(mapping :mapping.type)(mapping.selectable, _.selectForm)

	}



	class MappingWriteForm[M <: SingletonMapping](mapping :M, write :AnyComponent[M#Owner]=>SQLWriteForm[_], components :Seq[AnyComponent[M#Owner]])
		extends SQLWriteForm[M#Subject]
	{

		override def literal(value: M#Subject, inline :Boolean): String = {
			val literals = components.map { c =>
				val comp = c.asInstanceOf[mapping.Component[Any]]
				write(c).asInstanceOf[SQLWriteForm[Any]].literal((mapping \\ comp)(value.asInstanceOf[mapping.Subject]), inline)
			}
			if (inline) literals.mkString("", ", ", "")
			else literals.mkString("(", ", ", ")")
		}

		override def nullLiteral(inline :Boolean): String = {
			val literals = components.map(write(_).nullLiteral)
			if (inline) literals.mkString("", ", ", "")
			else literals.mkString("(", ", ", ")")
		}


		override def literal(value: M#Subject): String = literal(value, false)

		override def inlineLiteral(value: M#Subject): String = literal(value, true)

		override def nullLiteral: String = nullLiteral(false)

		override def inlineNullLiteral: String = nullLiteral(true)

		override val writtenColumns: Int = (0 /: components)(_ + write(_).writtenColumns)


		override def toString :String = components.map(write).mkString(s"$mapping{", ",", "}>")
	}


	object MappingWriteForm {
		def apply[E](mapping :Mapping[E])(components :Seq[mapping.Component[_]], write :mapping.Component[_]=>SQLWriteForm[_]) :SQLWriteForm[E] =
			new MappingWriteForm[mapping.type](mapping, write, components)


		def insertForm[E](mapping :Mapping[E]) :SQLWriteForm[E] = apply(mapping :mapping.type)(mapping.insertable, _.insertForm)
		def updateForm[E](mapping :Mapping[E]) :SQLWriteForm[E] = apply(mapping :mapping.type)(mapping.updatable, _.updateForm)
		def queryForm[E](mapping :Mapping[E]) :SQLWriteForm[E] = apply(mapping :mapping.type)(mapping.queryable, _.queryForm)

	}

}
