package net.noresttherein.oldsql.sql

import java.sql.{CallableStatement, Connection, PreparedStatement, Savepoint, ShardingKey}
import java.util
import java.util.concurrent.Executor
import java.util.Properties
import javax.sql.DataSource

import net.noresttherein.oldsql.{ThreadAsset, TransactionAPI}
import net.noresttherein.oldsql.Asset.TransactionAPIAsset
import net.noresttherein.oldsql.ManagedAsset.ManagedTransactionAPIAsset






/**
  * @author Marcin MoÅ›cicki
  */
trait SQLTransaction extends TransactionAPI {
	protected def connection :Connection

	override def commit() :Unit = connection.commit()
	override def clean() :Unit = connection.close()
	override def isOpen :Boolean = !connection.isClosed //consider: isValid instead (db roundtrip)

//	def createStatement(sql :String) :Statement = connection.createStatement()
	def prepareStatement(sql :String) :PreparedStatement = connection.prepareStatement(sql)
	def prepareCall(sql :String) :CallableStatement = connection.prepareCall(sql)

	//	protected def apply[T](block :Connection => T) :T
//	def close() :Unit
}



object SQLTransaction {
	def apply(connection :Connection) :SQLTransaction = new SQLConnectionAdapter(connection)

	def apply(database :DataSource) :SQLTransaction = SQLTransaction(database.getConnection)
	

	class SQLConnectionAdapter(protected override val connection :Connection) extends SQLTransaction {
		//todo: proxy to Connection so its rollback() also sets this flag (but this required also proxies to PreparedStatement and everything else
		private var isRolledback :Boolean = false

		override def rollback() :Unit = {
			isRolledback = true; connection.rollback()
		} //todo: savepoint api

		override def willRollback :Boolean = isRolledback

		private def status = if (connection.isClosed) "closed" else "open"

		override def toString = s"SQLTransaction($connection:$status)"
	}



	private class ConnectionAdapter(val connection :Connection) extends Connection {
		override def createStatement() = connection.createStatement()
		override def createStatement(resultSetType :Int, resultSetConcurrency :Int) =
			connection.createStatement(resultSetType, resultSetConcurrency)
		override def createStatement(resultSetType :Int, resultSetConcurrency :Int, resultSetHoldability :Int) =
			connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

		override def prepareStatement(sql :String) = connection.prepareStatement(sql)
		override def prepareStatement(sql :String, resultSetType :Int, resultSetConcurrency :Int) =
			connection.prepareStatement(sql, resultSetType, resultSetConcurrency)
		override def prepareStatement(sql :String, resultSetType :Int, resultSetConcurrency :Int, resultSetHoldability :Int) =
			connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
		override def prepareStatement(sql :String, autoGeneratedKeys :Int) =
			connection.prepareStatement(sql, autoGeneratedKeys)
		override def prepareStatement(sql :String, columnIndexes :Array[Int]) =
			connection.prepareStatement(sql, columnIndexes)
		override def prepareStatement(sql :String, columnNames :Array[String]) =
			connection.prepareStatement(sql, columnNames)

		override def prepareCall(sql :String) = connection.prepareCall(sql)
		override def prepareCall(sql :String, resultSetType :Int, resultSetConcurrency :Int) =
			connection.prepareCall(sql, resultSetType, resultSetConcurrency)
		override def prepareCall(sql :String, resultSetType :Int, resultSetConcurrency :Int, resultSetHoldability :Int) =
			connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

		override def createClob() = connection.createClob()
		override def createBlob() = connection.createBlob()
		override def createNClob() = connection.createNClob()
		override def createSQLXML() = connection.createSQLXML()
		override def createArrayOf(typeName :String, elements :Array[AnyRef]) =
			connection.createArrayOf(typeName, elements)
		override def createStruct(typeName :String, attributes :Array[AnyRef]) =
			connection.createStruct(typeName, attributes)

		override def nativeSQL(sql :String) = connection.nativeSQL(sql)

		override def commit() = connection.commit()
		override def rollback() = connection.rollback()
		override def rollback(savepoint :Savepoint) = connection.rollback(savepoint)
		override def releaseSavepoint(savepoint :Savepoint) = connection.releaseSavepoint(savepoint)
		override def close() = connection.close()
		override def isClosed = connection.isClosed
		override def isValid(timeout :Int) = connection.isValid(timeout)

		override def abort(executor :Executor) = connection.abort(executor)
		override def beginRequest() = connection.beginRequest()
		override def endRequest() = connection.endRequest()

		override def setAutoCommit(autoCommit :Boolean) = connection.setAutoCommit(autoCommit)
		override def getAutoCommit = connection.getAutoCommit

		override def setSavepoint() = connection.setSavepoint()
		override def setSavepoint(name :String) = connection.setSavepoint(name)

		override def setReadOnly(readOnly :Boolean) = connection.setReadOnly(readOnly)
		override def isReadOnly = connection.isReadOnly

		override def setCatalog(catalog :String) = connection.setCatalog(catalog)
		override def getCatalog = connection.getCatalog

		override def setTransactionIsolation(level :Int) = connection.setTransactionIsolation(level)
		override def getTransactionIsolation = connection.getTransactionIsolation

		override def getMetaData = connection.getMetaData
		override def setSchema(schema :String) = connection.setSchema(schema)
		override def getSchema = connection.getSchema

		override def getWarnings = connection.getWarnings
		override def clearWarnings() = connection.clearWarnings()

		override def getTypeMap = connection.getTypeMap
		override def setTypeMap(map :util.Map[String, Class[_]]) = connection.setTypeMap(map)

		override def setHoldability(holdability :Int) = connection.setHoldability(holdability)
		override def getHoldability = connection.getHoldability

		override def setClientInfo(name :String, value :String) = connection.setClientInfo(name, value)
		override def setClientInfo(properties :Properties) = connection.setClientInfo(properties)
		override def getClientInfo(name :String) = connection.getClientInfo(name)
		override def getClientInfo = connection.getClientInfo

		override def setNetworkTimeout(executor :Executor, milliseconds :Int) =
			connection.setNetworkTimeout(executor, milliseconds)
		override def getNetworkTimeout = connection.getNetworkTimeout

		override def setShardingKeyIfValid(shardingKey :ShardingKey, superShardingKey :ShardingKey, timeout :Int) =
			connection.setShardingKeyIfValid(shardingKey, superShardingKey, timeout)
		override def setShardingKeyIfValid(shardingKey :ShardingKey, timeout :Int) =
			connection.setShardingKeyIfValid(shardingKey, timeout)
		override def setShardingKey(shardingKey :ShardingKey, superShardingKey :ShardingKey) =
			connection.setShardingKey(shardingKey, superShardingKey)
		override def setShardingKey(shardingKey :ShardingKey) = connection.setShardingKey(shardingKey)

		override def unwrap[T](iface :Class[T]) = connection.unwrap(iface)
		override def isWrapperFor(iface :Class[_]) = connection.isWrapperFor(iface)
	}

}






trait SQLAsset extends TransactionAPIAsset {
	override type Transaction <: SQLTransaction

//	def execute[T](block :Connection => T)(implicit transaction :Transaction) :T = transaction(block)
}





object SQLAsset {

	def apply(dataSource :DataSource) :SQLAsset =
		new DataSourceAsset(dataSource)

	def apply(name: => String, dataSource :DataSource) :SQLAsset =
		new DataSourceAsset(dataSource) {
			override def toString = name
		}

	class DataSourceAsset(protected val dataSource :DataSource) extends SQLAsset {
		override type Transaction = SQLTransaction

		protected override def newTransaction :Transaction = SQLTransaction(dataSource)

		override def noTransaction :Transaction = null

		override def toString = s"SQLAsset($dataSource)"
	}

}





trait ManagedSQLAsset extends ManagedTransactionAPIAsset {
	override type Transaction <: SQLTransaction

//	def execute[T](block :Connection => T) :T = currentTransaction(block)
}






object ManagedSQLAsset {

	def apply(dataSource :DataSource) :ManagedSQLAsset =
		ManagedSQLAsset(s"ManagedSQLAsset($dataSource)", dataSource)

	def apply(name: => String, dataSource: DataSource) :ManagedSQLAsset =
		new ManagedDataSourceAsset(dataSource) with ThreadAsset {
			override def toString = name
		}

	abstract class ManagedDataSourceAsset(protected val dataSource :DataSource) extends ManagedSQLAsset {
		override type Transaction = SQLTransaction

		protected override def newTransaction :SQLTransaction = SQLTransaction(dataSource)
	}

}

